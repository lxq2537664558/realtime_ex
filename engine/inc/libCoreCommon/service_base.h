#pragma once

#include "core_common.h"
#include "ticker.h"
#include "actor_id_converter.h"
#include "service_id_converter.h"
#include "protobuf_factory.h"
#include "service_selector.h"
#include "actor_factory.h"

#include "libBaseCommon/buf_file.h"

namespace core
{
	// 服务状态 eSRS_Start->eSRS_Normal->eSRS_Quitting->eSRS_Quit
	// 其中eSRS_Quitting状态切换到eSRS_Quit是有逻辑层主动调用doQuit来完成的，
	// 这样做保证了关服前做一些需要比较长的时间来确认一些事的行为，比如数据存储
	enum EServiceRunState
	{
		eSRS_Start		= 0,	// 启动状态
		eSRS_Normal		= 1,	// 正常状态
		eSRS_Quitting	= 2,	// 退出中
		eSRS_Quit		= 3,	// 最终退出
	};

	class CActorBase;
	class CServiceInvoker;
	class CCoreService;
	/**
	@brief: 服务基础类
	*/
	class __CORE_COMMON_API__ CServiceBase :
		public base::noncopyable
	{
		friend class CCoreService;
		friend class CServiceInvoker;
		
	public:
		CServiceBase();
		virtual ~CServiceBase();

		uint32_t			getServiceID() const;
		/**
		@brief: 获取服务基础信息
		*/
		const SServiceBaseInfo&
							getServiceBaseInfo() const;

		/**
		@brief: 添加服务选择器
		*/
		void				setServiceSelector(const std::string& szType, CServiceSelector* pServiceSelector);
		/**
		@brief: 获取服务选择器
		*/
		CServiceSelector*	getServiceSelector(const std::string& szType) const;

		/**
		@brief: 注册定时器
		nStartTime 第一次触发定时器的时间
		nIntervalTime 第一次触发定时器后接下来定时器触发的间隔时间，如果该值是0就表示这个定时器只触发一次
		*/
		void				registerTicker(CTicker* pTicker, uint64_t nStartTime, uint64_t nIntervalTime, uint64_t nContext);
		/**
		@brief: 反注册定时器
		*/
		void				unregisterTicker(CTicker* pTicker);

		/**
		@brief: 注册普通服务消息
		*/
		void				registerServiceMessageHandler(const std::string& szMessageName, const std::function<void(CServiceBase*, SSessionInfo, const google::protobuf::Message*)>& callback);
		/**
		@brief: 注册经网关服务转发客户端的服务消息
		*/
		void				registerServiceForwardHandler(const std::string& szMessageName, const std::function<void(CServiceBase*, SClientSessionInfo, const google::protobuf::Message*)>& callback);
		
		/**
		@brief: 注册普通actor消息
		*/
		void				registerActorMessageHandler(const std::string& szMessageName, const std::function<void(CActorBase*, SSessionInfo, const google::protobuf::Message*)>& callback);
		/**
		@brief: 注册经网关服务转发客户端的actor消息
		*/
		void				registerActorForwardHandler(const std::string& szMessageName, const std::function<void(CActorBase*, SClientSessionInfo, const google::protobuf::Message*)>& callback);

		/**
		@brief: 获取客户端转发消息名字
		*/
		const std::string&	getForwardMessageName(uint32_t nMessageID);

		/**
		@brief: 设置全局的服务连接成功回调
		*/
		void				setServiceConnectCallback(const std::function<void(const std::string&, uint32_t)>& callback);
		/**
		@brief: 设置全局的服务连接断开回调
		*/
		void				setServiceDisconnectCallback(const std::function<void(const std::string&, uint32_t)>& callback);

		/**
		@brief: 获取服务调用器
		*/
		CServiceInvoker*	getServiceInvoker() const;
		/**
		@brief: 创建actor
		*/
		CActorBase*			createActor(const std::string& szType, uint64_t nActorID, const std::string& szContext);
		/**
		@brief: 销毁actor
		*/
		void				destroyActor(CActorBase* pActorBase);
		/**
		@brief: 根据id获取actor
		*/
		CActorBase*			getActorBase(uint64_t nID) const;
		/*
		@brief: 获取运行状态
		*/
		EServiceRunState	getRunState() const;
		/*
		@brief: 获取配置文件名
		*/
		const std::string&	getConfigFileName() const;
		/*
		@brief: 逻辑发出退出
		*/
		void				doQuit();

		/**
		@brief: 获取protobuf生成器
		*/
		virtual CProtobufFactory*
							getProtobufFactory() const = 0;

		/**
		@brief: 获取actor_id转换器
		*/
		virtual CActorIDConverter*
							getActorIDConverter() { return nullptr; }
		/**
		@brief: 设置service_id转换器
		*/
		virtual	CServiceIDConverter*
							getServiceIDConverter() { return nullptr; }
		/**
		@brief: 获取actor工厂
		*/
		virtual CActorFactory*
							getActorFactory(const std::string& szType) const { return nullptr; }

		virtual void		release() = 0;

	protected:
		virtual bool		onInit() = 0;
		virtual void		onFrame() { }
		virtual void		onQuit() = 0;

	private:
		CCoreService*	m_pCoreService;
	};
}