节点建连过程主要分两个阶段，连接master获取各个节点信息，根据这些节点信息连接目标节点。

连接master阶段
> 1. 节点启动时先连接master。
> 2. 连上后master向节点发送smt_sync_master_info消息。
> 3. 节点收到smt_sync_master_info消息后验证是否是重复的master，如果是就断开连接，否则通过smt_register_node_base_info消息发送本节点的信息以及本节点的一些服务信息给master。
> 4. master收到节点同步的消息后验证是否是重复节点以及重复服务，如果是直接断开连接，否则将master已经注册的节点以及其服务信息同步给新加入的节点，这里通过smt_sync_all_node_base_info消息发送，以及把新加入的节点信息以及其服务信息同步给其他节点，通过smt_sync_node_base_info消息完成。
> 5. 各个节点验证是否是重复节点以及重复服务，如果是忽略该消息，否则构建节点信息以及服务信息，并且如果该节点对新加入的服务感兴趣，就启动定时器试着连接该节点。

至此节点跟master之间的交互告一段落，接下来是各个节点之间的建连阶段了

> 1. 节点连接上目标节点后，连接发送方给目标节点发送smt_node_handshake_request消息来向目标节点请求握手。
> 2. 目标节点收到smt_node_handshake_request消息后首先判断是否是重复连接，如果是的就断开连接，否则会将连接信息加入到CServiceRegistryProxy中，并且响应握手消息smt_node_handshake_response 最后通知各个本节点的服务其他服务连接事件。
> 3. 目标节点收到smt_node_handshake_response消息后判断否是重复连接，如果是的就断开连接，否则会将连接信息加入到CGlobalServiceRegistryProxy中并且通知各个本节点的服务其他服务连接事件。

至此节点跟节点之间的建连也完成了


这里需要注意几个点
> 1. 节点下线处理。
> 2. 新节点上线时处理。
> 3. 节点跟master之间连接断开重连。
> 4. 节点之间连接断开重连。
> 5. 节点之间同时发起连接的处理。

节点下线处理
> 节点下线需要主动告诉所有master，节点崩溃，master跟节点之间断线都不算节点下线，各个master收到来自console（尚未实现）的节点下线消息后，广播节点下线消息给所有节点，节点收到其他节点下线消息后，做节点下线逻辑，需要注意的是节点收到其他节点下线消息时，可能跟其他节点还存在连接，这个时候需要断开该连接。

新节点上线时处理
> 新节点上线时，连上master后会把其他节点的信息通过给他，并且会把他的信息通知给新的节点。

节点跟master之间连接断开重连
> 节点跟master之间可能断线重连，在master跟节点上都需要处理这种情况，最需要注意的是在断线期间有其他节点下线了，此时节点上还有改其他节点的信息，需要在跟master断线重连后拿到所有其他节点的信息跟本地所有其他节点的信息做比对，对于多余的节点按照节点下线逻辑处理。

节点之间连接断开重连
> 节点之间用采用定时检测的方式来做断线重连

节点之间同时发起连接的处理
> 两个节点有时会存在需要相互连接对方的配置，比如节点A里面存在gate服务，节点B存在dispatch，gas服务，gate服务需要跟dispatch服务通讯，这样节点A需要主动连接节点B，gas服务需要跟gate服务通讯，这样节点B又需要主动连接节点B，这样的服务配置导致A，B两个节点会存在互连的情况，互连情况在我们框架下不被允许的，这样会带来网络消息的时序问题。

> 解决这个问题在master上处理，节点在连接上master上报自己需要连接的服务后，如果master发现存在互联的问题，就让节点id小的节点能连接节点id能够连接，反之就不让连接。

master服务是整个集群的关键服务，他一旦宕机虽然不影响已经运行的服务，但是新上线服务将无法工作，所以master被设计成允许多个master，各个节点全连所有master，所有master走一样的流程，这样master上的数据是最终一致的，一个宕机不影响其他master，整个集群只要存在一个master就能正常工作。


上面过程其他就是一个服务治理过程示意图如下
![image](https://github.com/bruan/realtime_ex/raw/master/doc/image/register.png)